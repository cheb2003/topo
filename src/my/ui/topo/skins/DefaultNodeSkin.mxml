<?xml version="1.0"?>
<s:SparkSkin creationComplete="init()" xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark" width="80" height="60">
    <fx:Metadata>
        <![CDATA[
        [HostComponent("my.ui.topo.Node")]
        ]]>
    </fx:Metadata>
	<fx:Script>
		<![CDATA[
        import mx.controls.Alert;
        import mx.events.EffectEvent;
			import flash.filters.BitmapFilterQuality;
			import flash.filters.BitmapFilterType;
      		private var a1Playing:Boolean;
            private var isMouseOver:Boolean
			[Bindable]
			private var arr:Array = new Array();
            private const spr1:Sprite = new Sprite();
            private function init():void {
				if(hostComponent.isBase)
					arr.push(baseGlow);
				else
					arr.push(glow);
				img.filters = arr;
                addEventListener(MouseEvent.MOUSE_MOVE,mouseMoveHandler)
                //sve.addEventListener(MouseEvent.ROLL_OVER, rollOverHandler, false, 0, true);
                addEventListener(MouseEvent.ROLL_OUT, rollOutHandler, false, 0, true);
                spr1.graphics.beginFill(0xffffff, 0);
                spr1.graphics.drawRect(-35, -30, 75, 30);
                spr1.graphics.endFill();
                sve.addChild(spr1);
            }

            private function mouseMoveHandler(event:MouseEvent):void {
                if(img.hitTestPoint(event.stageX, event.stageY) || sve.hitTestPoint(event.stageX, event.stageY)
                        || (bc.visible == true && bc.hitTestPoint(event.stageX, event.stageY))) {
                    if(!isMouseOver){
                        isMouseOver = true;
                        rollOverHandler(event);
                    }
                } else {
                    if(isMouseOver) {
                        rollOutHandler(event);
                        isMouseOver = false;
                    }
                }
            }
            private function rollOutHandler(event:MouseEvent):void {
                if(isMouseOver) {
                    isMouseOver = false;
                    if(a1Playing) {
                        if(p1.isPlaying) {
                            p1.reverse()
                            hostComponent.depth = Math.abs(Math.random())
                            showBC(false)
                        }
                        if(p2.isPlaying) {
                            p2.reverse()
                            hostComponent.depth = int.MAX_VALUE
                            showBC(true)
                        }
                        a1Playing = false;
                        return
                    }
                    if(width > 80 && width <= 120) {
                        p2.play()
                        hostComponent.depth = Math.abs(Math.random());
                    }
                }
            }
            private function rollOverHandler(event:MouseEvent):void {
                if(a1Playing) {
                    if(p1.isPlaying) {
                        p1.reverse()
                        hostComponent.depth = Math.abs(Math.random())
                        showBC(false)
                    }
                    if(p2.isPlaying) {
                        p2.reverse()
                        hostComponent.depth = int.MAX_VALUE
                        showBC(true)
                    }
                    a1Playing = false;
                    return
                }
                if(width <= 80) {
                    p1.play();
                    hostComponent.depth = int.MAX_VALUE
                }
            }

			protected function effectEndHandler(event:EffectEvent):void
			{
				if (a1Playing)
				{
					a1Playing = false;
                    if(isMouseOver) {
                        showBC(true)
                    }
				}
			}
            private function showBC(b:Boolean):void{
                bc.includeInLayout = b;
                bc.visible = b;
                label.includeInLayout = !b;
                label.visible = !b;
            }
			protected function effectStartHandler(event:EffectEvent):void
			{
				if (!a1Playing)
				{
					a1Playing = true;
					showBC(false)
				}
			}

            private function fix():void {
                if(width < 80 || width > 120) {
                    width = 80
                    height = 60
                }
            }

            private function fixBC():void {
                if(!isMouseOver) {
                    showBC(false)
                }
            }

            private function bcClick():void {
                Alert.show("click")
            }

			protected function img_doubleClickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				if (hostComponent.isBase)
					return;
				hostComponent.topoGraph.removeAllNode(hostComponent.id);
			}
			
		]]>
	</fx:Script>
    <fx:Declarations>
		<s:GradientGlowFilter id="baseGlow" 
							  blurX="30" blurY="30"
							  quality="{BitmapFilterQuality.HIGH}"
							  type="{BitmapFilterType.OUTER}" 
							  knockout="false">
			<s:entries>
				<s:GradientEntry alpha="0" color="0xFF0000" ratio="0"/>
				<s:GradientEntry alpha="0.8" color="0xFF0000" ratio="128"/>
				<s:GradientEntry alpha="0.8" color="0xFF0000" ratio="255"/>
			</s:entries>
		</s:GradientGlowFilter>
		<s:GradientGlowFilter id="glow" 
				  blurX="30" blurY="30"
				  quality="{BitmapFilterQuality.HIGH}"
				  type="{BitmapFilterType.OUTER}" 
				  knockout="false">
			<s:entries>
				<s:GradientEntry alpha="0" color="0x3333FF" ratio="0"/>
				<s:GradientEntry alpha="0.8" color="0x3333FF" ratio="128"/>
				<s:GradientEntry alpha="0.8" color="0x3333FF" ratio="255"/>
			</s:entries>
		</s:GradientGlowFilter>
        <s:Parallel id="p1" effectEnd="fix()">
            <s:Resize target="{this}" id="r1"  widthFrom="{width}" heightFrom="{height}" heightTo="{height + 40}" widthTo="{width + 40}"/>
            <s:Animate id="a1" target="{this}" effectStart="{a1Playing = true}" effectEnd="effectEndHandler(event)">
                <s:SimpleMotionPath property="x" valueFrom="{x}" valueTo="{x - 10}"/>
                <s:SimpleMotionPath property="y" valueFrom="{y}" valueTo="{y - 10}"/>
            </s:Animate>
        </s:Parallel>
        <s:Parallel id="p2" effectEnd="fix()">
            <s:Resize target="{this}"  widthFrom="{width}" heightFrom="{height}" heightTo="{height - 40}" widthTo="{width - 40}"/>
            <s:Animate target="{this}" effectStart="effectStartHandler(event)" effectEnd="{a1Playing = false}">
                <s:SimpleMotionPath property="x" valueFrom="{x}" valueTo="{x + 10}"/>
                <s:SimpleMotionPath property="y" valueFrom="{y}" valueTo="{y + 10}"/>
            </s:Animate>
        </s:Parallel>
		
		<s:Move id="nodeTipEffect" target="{bc}" yFrom="{bc.y + 15}" yTo="{bc.y}" duration="300" effectEnd="fixBC()"/>
    </fx:Declarations>

    <s:states>
        <s:State name="normal">
        </s:State>
        <s:State name="selectedAndShowLabel"/>
        <s:State name="selected"/>
        <s:State name="mouseOver"/>
    </s:states>

    <s:SpriteVisualElement id="sve" y="60"></s:SpriteVisualElement>
    <s:Image doubleClickEnabled="true" doubleClick="img_doubleClickHandler(event)"
            source="{hostComponent.imageSource}" id="img" x="{-img.width/2}" y="{-img.height/2}" width="{this.width}" height="{this.height}"/>
    <s:Label id="label"  x="{img.x}" y="{img.y+img.height+5}" width="{img.width}" textAlign="center" text="{hostComponent.labelName}" />
    <s:BorderContainer mouseOver="{bc.setStyle('backgroundColor',0x544E6C)}" mouseOut="{bc.setStyle('backgroundColor',0xffffff)}" click="bcClick()" id="bc" visible="false" includeInLayout="false" width="235" height="40" x="{img.x+img.width/2-this.width/2-30}" y="{img.y+img.height}"
                       cornerRadius="5" borderWeight="2" dropShadowVisible="false" showEffect="{nodeTipEffect}" color="0x999999">
        <s:Label x="5" y="13" text=">>" color="0x4fBEF1" fontWeight="bold"/>
        <s:Label x="20" y="5" text="{hostComponent.labelName}" color="0x45BEF4" fontSize="14"/>
        <s:Label x="20" y="20" text="{hostComponent.info}" color="0x000000" fontSize="12"/>
    </s:BorderContainer>




</s:SparkSkin>
